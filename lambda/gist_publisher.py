import json
import boto3
import requests
from datetime import datetime
from typing import Dict, List
import logging
import os

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Initialize AWS clients
s3 = boto3.client('s3')

def get_rpi_results_from_s3(bucket: str, calculation_date: str) -> Dict:
    """
    Retrieve RPI results from S3
    """
    try:
        # Get JSON results
        json_key = f"rpi_results/{calculation_date}/rpi_results.json"
        response = s3.get_object(Bucket=bucket, Key=json_key)
        results = json.loads(response['Body'].read().decode('utf-8'))
        
        # Get CSV results
        csv_key = f"rpi_results/{calculation_date}/rpi_results.csv"
        csv_response = s3.get_object(Bucket=bucket, Key=csv_key)
        csv_content = csv_response['Body'].read().decode('utf-8')
        
        return {
            'json_results': results,
            'csv_content': csv_content,
            'calculation_date': calculation_date
        }
        
    except Exception as e:
        logger.error(f"Error retrieving RPI results from S3: {str(e)}")
        raise

def create_gist_description(calculation_date: str, results: List[Dict]) -> str:
    """
    Create a descriptive text for the gist
    """
    top_10_teams = results[:10]
    
    description = f"""NCAA Women's Soccer RPI Rankings - {calculation_date}

This gist contains the latest RPI (Rating Percentage Index) calculations for NCAA Division I women's soccer teams.

RPI Formula: RPI = (0.25 × WP) + (0.50 × OWP) + (0.25 × OOWP)
- WP = Winning Percentage
- OWP = Opponents' Winning Percentage  
- OOWP = Opponents' Opponents' Winning Percentage

Top 10 Teams:
"""
    
    for i, team in enumerate(top_10_teams, 1):
        description += f"{i}. {team['team']} - RPI: {team['rpi']} (Record: {team['wins']}-{team['losses']}-{team['ties']})\n"
    
    description += f"\nTotal teams ranked: {len(results)}"
    description += f"\nCalculation date: {calculation_date}"
    description += f"\nGenerated by NCAA Soccer ETL System"
    
    return description

def create_gist_files(results: List[Dict], csv_content: str, calculation_date: str) -> Dict:
    """
    Create the files to be included in the gist
    """
    # Create JSON file content
    json_content = json.dumps(results, indent=2)
    
    # Create summary file content
    summary_content = f"""NCAA Women's Soccer RPI Rankings - {calculation_date}

Top 25 Teams:
"""
    
    for i, team in enumerate(results[:25], 1):
        summary_content += f"{i:2d}. {team['team']:<30} RPI: {team['rpi']:6.4f} ({team['wins']:2d}-{team['losses']:2d}-{team['ties']:2d})\n"
    
    summary_content += f"\nFull data available in rpi_results_{calculation_date}.json and rpi_results_{calculation_date}.csv"
    
    files = {
        f"rpi_results_{calculation_date}.json": {
            "content": json_content
        },
        f"rpi_results_{calculation_date}.csv": {
            "content": csv_content
        },
        f"rpi_summary_{calculation_date}.txt": {
            "content": summary_content
        }
    }
    
    return files

def create_github_gist(files: Dict, description: str, github_token: str) -> str:
    """
    Create a GitHub gist with the RPI data
    """
    url = 'https://api.github.com/gists'
    
    headers = {
        'Authorization': f'token {github_token}',
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
    }
    
    data = {
        'description': description,
        'public': True,
        'files': files
    }
    
    try:
        response = requests.post(
            url, 
            headers=headers, 
            data=json.dumps(data), 
            timeout=30
        )
        response.raise_for_status()
        
        gist_data = response.json()
        gist_url = gist_data['html_url']
        
        logger.info(f"Created GitHub gist: {gist_url}")
        return gist_url
        
    except requests.exceptions.RequestException as e:
        logger.error(f"Error creating GitHub gist: {str(e)}")
        raise

def update_existing_gist(gist_id: str, files: Dict, description: str, github_token: str) -> str:
    """
    Update an existing gist (if we want to maintain a single gist)
    """
    url = f'https://api.github.com/gists/{gist_id}'
    
    headers = {
        'Authorization': f'token {github_token}',
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
    }
    
    data = {
        'description': description,
        'files': files
    }
    
    try:
        response = requests.patch(
            url, 
            headers=headers, 
            data=json.dumps(data), 
            timeout=30
        )
        response.raise_for_status()
        
        gist_data = response.json()
        gist_url = gist_data['html_url']
        
        logger.info(f"Updated GitHub gist: {gist_url}")
        return gist_url
        
    except requests.exceptions.RequestException as e:
        logger.error(f"Error updating GitHub gist: {str(e)}")
        raise

def store_gist_metadata_in_s3(gist_url: str, calculation_date: str, bucket: str):
    """
    Store gist metadata in S3 for tracking
    """
    metadata = {
        'gist_url': gist_url,
        'calculation_date': calculation_date,
        'created_at': datetime.now().isoformat(),
        'status': 'published'
    }
    
    key = f"gist_metadata/{calculation_date}/gist_metadata.json"
    
    try:
        s3.put_object(
            Bucket=bucket,
            Key=key,
            Body=json.dumps(metadata, indent=2),
            ContentType='application/json'
        )
        logger.info(f"Stored gist metadata in S3: {key}")
    except Exception as e:
        logger.error(f"Error storing gist metadata: {str(e)}")

def lambda_handler(event, context):
    """
    Lambda handler for gist publishing
    """
    try:
        # Get environment variables
        processed_data_bucket = os.environ['PROCESSED_DATA_BUCKET']
        github_token = os.environ['GITHUB_TOKEN']
        
        # Get calculation date from event or use current date
        if 'calculation_date' in event:
            calculation_date = event['calculation_date']
        else:
            calculation_date = datetime.now().strftime("%Y-%m-%d")
        
        logger.info(f"Publishing gist for calculation date: {calculation_date}")
        
        # Get RPI results from S3
        rpi_data = get_rpi_results_from_s3(processed_data_bucket, calculation_date)
        results = rpi_data['json_results']
        csv_content = rpi_data['csv_content']
        
        if not results:
            logger.warning("No RPI results found for gist publishing")
            return {
                'statusCode': 200,
                'body': json.dumps({
                    'message': 'No RPI results found for gist publishing',
                    'calculation_date': calculation_date
                })
            }
        
        # Create gist description
        description = create_gist_description(calculation_date, results)
        
        # Create gist files
        files = create_gist_files(results, csv_content, calculation_date)
        
        # Create GitHub gist
        gist_url = create_github_gist(files, description, github_token)
        
        # Store gist metadata in S3
        store_gist_metadata_in_s3(gist_url, calculation_date, processed_data_bucket)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Successfully published gist',
                'gist_url': gist_url,
                'calculation_date': calculation_date,
                'teams_count': len(results)
            })
        }
        
    except Exception as e:
        logger.error(f"Error in gist publisher: {str(e)}")
        raise 